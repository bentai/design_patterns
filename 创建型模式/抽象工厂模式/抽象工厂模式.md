# 抽象工厂  Abstract Factory
### 1、模式概述
抽象工厂模式为一组相关或相互依赖的对象创建提供接口，而无需指定其具体实现类。抽象工厂的客户端不关心
如何创建这些对象，只关心如何将它们组合到一起。
### 2、问题引出
举个例子，如果某个应用是可移植的，那么它需要封装平台依赖，这些平台可能包括窗口系统、操作系统、数据库等等。
这种封装如果未经设计，通常代码会包含多个 if 条件语句以及对应平台的操作。这种硬编码不仅可读性差，
而且拓展性也不好。
### 3、解决方案
提供一个间接的层（即"抽象工厂"）抽象一组相关或依赖对象的创建而不是指定具体实现类。该"工厂"对象的职责
是为不同平台提供创建服务。客户端不需要直接创建平台对象，而是让工厂去做这件事。

这种机制让替换平台变得简单，因为抽象工厂的具体实现类只有在实例化的时候才出现，如果要替换的话只需要在
实例化的时候指定具体实现类即可。 

### 4、UML类图
抽象工厂为每个产品（具体实现）定义了工厂方法，
每个工厂方法封装了new操作符和具体类（指定平台的产品类），每个“平台”都是抽象工厂的派生类。


>![UML](https://qcdn.xueyuanjun.com/wp-content/uploads/2015/12/78bd6487-a8c4-443c-a6c7-7f8aa13ff4c3.png)

### 5、结构
抽象工厂模式包含一下四个角色：
- AbstractFactory (抽象工厂类)
- ConcreteFactory (具体工厂类)
- AbstractProduct (抽象产品类)
- ConcreteProduct (具体工厂类)

### 6、优点
- 隔离了具体类的生成，使得客户端并不需要知道什么被创建
- 当一个产品族中多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象
- 增加新的产品族很方便，无需修改已有系统，符合开闭原则。
> 产品族是以产品平台为基础，通过添加不同的个性模块，以满足不同客户个性化需求的一组相关产品。
> 开闭原则：设计模式六大原则之一，软件对象（类、模块、方法等）应该对于拓展是开放的，对修改是关闭的。
### 7、缺点
增加新的产品等级结构麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，
这显然会带来较大的不便，违背了开闭原则

