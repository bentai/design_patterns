# 代理模式

### 1、 定义
代理模式是一种结构型设计模式，让你能够提供对象的替代品或其占位符。代理控制着对于原对象的访问，
并允许在将请求提交给对象前后进行一些处理
### 2、 应用场景
- 延迟初始化（虚拟代理）。如果你有一个偶尔使用的重量级服务对象，一直保持该对象运行会消耗系统资源时，可使用代理模式
  + 你无需在程序启动时就创建该对象，可将对象的初始化延迟到真正需要的时候。
  
- 访问控制（保护代理）。如果你只希望特定客户端使用服务对象，这里的对象可以是操作系统中非常重要的部分，
  而客户端则是各种已启动的程序（包括恶意服务），此时可使用代理模式。
  + 代理可仅在客户端凭据满足要求时将请求传递给服务对象。
  
- 本地执行远程服务（远程代理）。适用于服务对象位于服务器上的情形。
  + 在这种情况中，代理通过网络传递客户端请求，负责处理所有于网络相关的复杂细节。
  
- 记录日志请求（日志记录处理）。适用于当你需要保存对于服务对象的请求历史记录时。代理可以在想服务
  传递请求前进行记录。
  + 缓存请求结果（缓存代理）。适用于需要缓存客户请求结果并对缓存生命周期进行管理时，特别是当返回、
    结果的体积非常大时。
    * 代理可对重复请求所需的相同结果进行缓存，还可使用请求参数作为索引缓存的键值。

### 3、优点
- 你可以在客户端毫无察觉的情况下控制服务对象。
- 如果客户端对服务对象的生命周期没有特殊要求，你可以对生命周期进行管理。
- 即使服务对象还未准备好或不存在，代理也可以正常工作。
- 开闭原则。 你可以在不对服务或客户端做出修改的情况下创建新代理。

### 4、缺点
- 代码可能会变得复杂，因为需要新建很多类
- 服务相应可能会延迟
 ### 5、与其他模型的关系
 - 适配器模式  ---  适配器模式为它所适配的对象提供一个不同的接口，而代理提供了与它的实体相同的接口
 - 装饰器模式  ---  两者的目的不同：装饰器为对象添加一个或多个功能，而代理控制对对象的访问。
 
 - 适配器模式能为被封装对象提供不同的接口，代理模式能为对象提供相同的接口，装饰模式能为对象提供加强的接口
 - 外观模式和代理的相似之处在于他们都缓存了一个复杂实体并自动对其进行初始化。代理与其服务对象遵循同一接口，
   使得自己与服务对象可以互换，在这一点上他与外观不同。
- 装饰和代理有着相似的结构，但是其意图却非常不同，这两个模式的构建都基于组合原则，也就是所一个对象应该将
  部分工作委派给另一个对象。两者之间的不同之处在于代理通常自行管理其服务对象的生命周期，而装饰的生成
  总是由客户端控制。

    